# Task: Refactor and Modularize main.py

**Date:** 2025-10-24
**Status:** In Progress
**Priority:** High

## Problem Statement

The `main.py` file has grown to 740+ lines with significant complexity:
- Large `execute_workflow()` function with deeply nested conditionals
- Node type logic scattered throughout (if ProtoAgentNode, elif ProtoOutputNode, etc.)
- Mixed concerns: API routing, workflow orchestration, node execution, LLM streaming, variable resolution
- Difficult to test individual components
- Hard to add new node types without modifying multiple sections

## Goals

1. **Separation of Concerns**: Split monolithic code into focused, single-responsibility modules
2. **Object-Oriented Design**: Use base classes and inheritance for node types
3. **Maintainability**: Make it easy to add new node types without touching existing code
4. **Testability**: Enable unit testing of individual components
5. **Readability**: Reduce main.py to ~150 lines of API routing logic

## Proposed Architecture

### Directory Structure

```
proto-engine/
├── main.py                      # FastAPI app, endpoints only (~150 lines)
├── schemas.py                   # Pydantic models (WorkflowRequest, etc.)
│
├── config/
│   ├── __init__.py
│   ├── settings.py              # Logging, CORS, dotenv loading
│   └── node_definitions.py      # EXPERIMENTAL_NODES dict for frontend /nodes endpoint
│
├── nodes/
│   ├── __init__.py              # Exports all node classes
│   ├── base.py                  # BaseNode abstract class
│   ├── agent_node.py            # ProtoAgentNode(BaseNode)
│   ├── output_node.py           # ProtoOutputNode(BaseNode)
│   ├── schema_node.py           # ProtoSchemaNode(BaseNode)
│   └── dynamic_text_node.py     # ProtoDynamicTextNode(BaseNode)
│
├── workflow/
│   ├── __init__.py
│   ├── executor.py              # WorkflowExecutor class (orchestration)
│   ├── graph.py                 # get_execution_order() - topological sort
│   └── resolver.py              # resolve_inputs() - {{variable}} replacement
│
└── llm/
    ├── __init__.py
    └── streaming.py             # stream_llm_response() - OpenAI/Anthropic integration
```

### Key Design Patterns

#### 1. BaseNode Pattern

```python
# nodes/base.py
from abc import ABC, abstractmethod
from typing import Any, Dict

class BaseNode(ABC):
    def __init__(self, node_data: Dict[str, Any]):
        self.node_id = node_data.get("id")
        self.node_type = node_data.get("data", {}).get("nodeType")
        self.node_inputs = node_data.get("data", {}).get("nodeInputs", {})
    
    @abstractmethod
    async def execute(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the node's logic.
        
        Args:
            state: Dictionary of all previous node outputs
        
        Returns:
            Dictionary of this node's outputs
        """
        raise NotImplementedError
```

#### 2. WorkflowExecutor Pattern

The executor manages:
- Topological sorting of nodes
- State management (node_outputs)
- Event streaming (SSE)
- Node instantiation and execution

```python
# workflow/executor.py
class WorkflowExecutor:
    def __init__(self, nodes: Dict, edges: List):
        self.nodes = nodes
        self.edges = edges
        self.node_outputs = {}
    
    async def execute(self):
        """Main execution loop with SSE streaming"""
        execution_order = get_execution_order(self.nodes, self.edges)
        
        for node_id in execution_order:
            node_class = self._get_node_class(node_type)
            node_instance = node_class(node_data)
            result = await node_instance.execute(self.node_outputs)
            self.node_outputs[node_id] = result
            yield event(...)
```

#### 3. Input Resolution Pattern

```python
# workflow/resolver.py
def resolve_inputs(node_inputs: Dict, state: Dict, edges: List, node_id: str) -> Dict:
    """
    Resolves {{variable}} placeholders and edge connections.
    
    - Handles variable interpolation in text fields
    - Maps edge connections to input values
    - Returns fully resolved inputs ready for node execution
    """
```

## Implementation Plan

### Phase 1: Infrastructure Setup ✓
- [x] Create directory structure (config/, nodes/, workflow/, llm/)
- [x] Create all __init__.py files
- [ ] Document task in tasks/refactor-modularize-main.md

### Phase 2: Extract Configuration & Schemas
- [ ] Create `schemas.py` with WorkflowRequest model
- [ ] Create `config/settings.py` with logging and CORS setup
- [ ] Create `config/node_definitions.py` with EXPERIMENTAL_NODES dict

### Phase 3: Extract Core Utilities
- [ ] Create `llm/streaming.py` with stream_llm_response()
- [ ] Create `workflow/graph.py` with topological sort logic
- [ ] Create `workflow/resolver.py` with input resolution

### Phase 4: Create Node Classes
- [ ] Create `nodes/base.py` with BaseNode abstract class
- [ ] Create `nodes/agent_node.py` - ProtoAgentNode
- [ ] Create `nodes/output_node.py` - ProtoOutputNode
- [ ] Create `nodes/schema_node.py` - ProtoSchemaNode
- [ ] Create `nodes/dynamic_text_node.py` - ProtoDynamicTextNode
- [ ] Update `nodes/__init__.py` to export all node classes

### Phase 5: Create Workflow Executor
- [ ] Create `workflow/executor.py` with WorkflowExecutor class
- [ ] Implement SSE streaming in executor
- [ ] Integrate with node classes

### Phase 6: Refactor main.py
- [ ] Import new modules
- [ ] Simplify /execute endpoint to delegate to WorkflowExecutor
- [ ] Simplify /nodes endpoint to return config/node_definitions
- [ ] Remove all extracted code
- [ ] Verify main.py is ~150 lines

### Phase 7: Testing & Validation
- [ ] Test each node type individually
- [ ] Test workflow execution with multiple node types
- [ ] Verify SSE streaming still works
- [ ] Test variable resolution with {{variables}}
- [ ] Test JSON schema output
- [ ] Verify logging still works correctly

## Success Criteria

- [ ] main.py reduced to ~150 lines
- [ ] Each node type is a separate class in nodes/
- [ ] No if/elif chains for node type detection
- [ ] All tests pass (if tests exist)
- [ ] Server starts and executes workflows correctly
- [ ] Easy to add new node types by creating a new file in nodes/

## Benefits

1. **Scalability**: Adding new node types requires only creating a new file in nodes/
2. **Testability**: Each component can be unit tested independently
3. **Maintainability**: Clear separation of concerns makes code easy to understand
4. **Professional Structure**: Follows Python best practices and design patterns
5. **Reduced Complexity**: No more giant if/elif chains or nested conditionals

## Notes

- Keep original main.py as main.py.backup until refactor is validated
- Ensure all logging statements are preserved
- Maintain backward compatibility with frontend API contract
- Test thoroughly before considering complete

## Related Files

- Current: `/Users/scottbaggett/code/salt/proto-engine/main.py` (740 lines)
- Target: Distributed across multiple focused modules

## References

- Original discussion: User noted "getting a bit convoluted" with "a lot of if this node then that"
- Design pattern: Strategy Pattern + Factory Pattern for node execution
